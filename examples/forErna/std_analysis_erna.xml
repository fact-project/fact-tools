<container>
    <!--
    This Process contains the standard analysis for FACT, with modifications to be used with the SGE/TORQUE cluster
    execution tool ERNA (Easy RuN Access) https://github.com/fact-project/erna
    -->
    <properties url="classpath:/default/settings.properties" />

    <property name="aux_source" value="file:./2015.sqlite" />

    <property name="integralGainFile" value="classpath:/default/gain_sorted_20131127.csv" />
    <property name="pixelDelayFile" value="classpath:/default/delays_lightpulser_20150217.csv" />

    <service id="auxService" class="fact.auxservice.SqliteService" url="${aux_source}" />
    <service id="calibService" class="fact.calibrationservice.ConstantCalibService" />

    <!-- Has to be a  FactFileListMultiStream in order to work on tasks from gridmap and the executor script.-->
    <stream id="fact" class="fact.io.FactFileListMultiStream"   url="${input}">
        <stream class="fact.io.hdureader.FITSStream" id="_" />
    </stream>

    <process id="1" input="fact">
        <fact.extraction.SaturatedSlicesPercentage />
        <Skip condition="%{data.saturatedSlicesPercentage} &gt; 0.2" />
        <!-- prevEventAndSkip: -->
        <!-- PreviousEventInfo, Skip(no Data Trigger) -->
        <include url="classpath:/default/data/prevEventAndSkip.xml" />
        <!-- Output: Data -->

	<fact.features.UnixTimeUTC2DateTime />

        <!-- Calibration: -->
        <fact.datacorrection.DrsCalibration
                key="Data"
                outputKey="DataCalibrated"
        />
        <fact.datacorrection.PatchJumpRemoval
                dataKey="DataCalibrated"
                outputKey="DataCalibrated"
                prevEventsKey="prevEvents"
                startCellKey="StartCellData"
                jumpLimit="${patchJumpRemoval_jumpLimit}"
        />
        <fact.datacorrection.RemoveSpikes
                dataKey="DataCalibrated"
                outputKey="DataCalibrated"
                startCellKey="StartCellData"
                leftBorder="${removeSpikes_leftBorder}"
                spikeLimit="${removeSpikes_spikeLimit}"
                topSlopeLimit="${removeSpikes_topSlopeLimit}"
                maxSpikeLength="${removeSpikes_maxSpikeLength}"
        />
        <fact.datacorrection.DrsTimeCalibration
                dataKey="DataCalibrated"
                outputKey="DataCalibrated"
        />
        <fact.datacorrection.InterpolateTimeSeries
                calibService="calibService"
                dataKey="DataCalibrated"
                dataOutputKey="DataCalibrated"
        />

        <!-- Extraction -->
        <!-- BasicExtraction, RisingEdgeForPositions, RisingEdgePolynomFit, TimeOverThreshold,
        PhotonChargeTimeOverThreshold, HandleSaturation, CorrectPixelDelays-->
        <include url="classpath:/default/data/extraction.xml" />
        <!-- Output: photoncharge, arrivalTime -->

        <!-- Cleaning -->
        <!-- SourcePosition(Cetatauri), CoreNeighborCleanTimeNeighbor-->
        <include url="classpath:/default/data/cleaning.xml" />
        <!-- Output: shower -->

        <!-- pedestal parameters -->
        <!-- WaveformFluctuation on non-cleaning pixels-->
        <include url="classpath:/default/mc/pedestalParameters_mc.xml" />

        <!-- Parameter calculation (only source independent) -->
        <!-- ArrayMean(photoncharge,arrivalTime), ArrayStatistics(photoncharge,arrivalTime,maxSlopes,
        arrivalTimePos,maxSlopesPos,maxAmplitudePosition,photonchargeSaturated,arrivalTimeTOT),
        HillasParameters, NumberOfIslands, TimeGraident,
        Concentration, ConcentrationCore, ConcentrationAtCenterOfGravity, Leakage, TimeSpread,
        ShowerSlope, Disp -->
        <include url="classpath:/default/data/parameterCalc.xml" />
        <!-- Output: source independent parameters -->

        <fact.features.source.SourcePosition outputKey="sourcePosition" auxService="auxService" />

        <fact.utils.SanitizeKeys />
        <!-- its important that you output a valid json file for this to work in conjuction with gridmap -->
        <fact.io.JSONWriter keys="${keysForOutput}"
            url="${output}"
            writeListOfItems="True"
            specialDoubleValuesAsString="True"
            pixelSetsAsInt="True"
            />
        <!-- <PrintData/> -->
        <!-- <fact.io.PrintKeys keys="${keysForOutput}" /> -->
    </process>
</container>
