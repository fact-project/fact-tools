<container>

    <properties url="classpath:/default/settings_mc.properties" />

    <!--<property name="twoLevelTimeNeighbor_neighborThreshold" value="2.0" />-->
    <!--<property name="twoLevelTimeNeighbor_coreThreshold" value="4.0" />-->


    <property name="basicExtraction_startSearchWindow" value="15" />
    <property name="basicExtraction_rangeSearchWindow" value="135" />
    <property name="basicExtraction_rangeHalfHeigthWindow" value="5" />



    <!-- Pathes to the input files -->

    <property name="infolder" value="file:/Users/lena/Documents/Masterarbeit/FACT_Data/MC/Gamma/" />

    <property name="outfolder" value="file:/Users/lena/Documents/Masterarbeit/Separation/" />
    <property name="filename" value="gamma_correlation_test" />
    <property name="label" value="1"/>




    <property name="integralGainFile" value="classpath:/default/defaultIntegralGains.csv" />
    <property name="drsfile" value="classpath:/testMcDrsFile.drs.fits.gz" />

    <!--<property name="drsfile" value="file:/home/llinhoff/testMcDrsFile.drs.fits.gz" />-->


    <service id="auxService" class="fact.auxservice.AuxFileService" auxFolder="file:src/main/resources/aux/" />

    <service id="calibService" class="fact.calibrationservice.ConstantCalibService" />


    <stream id="fact" class="fact.io.RecursiveDirectoryStream"
            pattern="*_Events.fits.gz"  url="${infolder}" limit="5000">
        <stream class="fact.io.FitsStream" id="_" />
    </stream>

    <process id="2" input="fact">

        <stream.flow.Skip condition="%{data.TriggerType} != 4" />
        <!--<Skip condition="%{data.EventNum} != 13 "/>-->

        <include url="classpath:/default/mc/calibration_mc.xml" />

        <include url="classpath:/default/mc/extraction_mc.xml" />

        <include url="classpath:/default/mc/cleaning_mc.xml" />

        <Skip condition="%{data.shower} == null" />

        <include url="classpath:/default/mc/parameterCalc_mc.xml" />

        <include url="classpath:/default/mc/sourceParameter_mc.xml" />

        <!--<Skip condition="%{data.shower} == null" />-->


        <fact.extraction.MeanCorrelation
            key="DataCalibrated"
            amplitudePositionsKey="maxPos"
            skipLast="50"
            />

        <fact.cleaning.TwoLevelTimeNeighbor
                calibService="calibService"
                photonChargeKey="meanCorrelation"
                outputKey="showerCorrelation"
                arrivalTimeKey="meanCorrelation"
                corePixelThreshold="5.0"
                neighborPixelThreshold="1.0"
                timeLimit="${twoLevelTimeNeighbor_timeLimit}"
                minNumberOfPixel="${twoLevelTimeNeighbor_minNumberOfPixel}"
        />

        <Skip condition="%{data.showerCorrelation} == null" />


        <fact.features.watershed.ClusterFellwalker
                arrivaltimePosKey = "arrivalTime"
                pixelSetKey="showerCorrelation"
                photonchareKey="photoncharge"
                morphologyKey="meanCorrelation"
                minShowerpixel="2"
        />   <!--areaKey="showerCorrelation"-->

        <!--<fact.features.watershed.ClusterArrivalTimes-->
                <!--arrivaltimePosKey = "arrivalTime"-->
                <!--pixelSetKey="showerCorrelation"-->
                <!--threshold="2"-->

        <!--/>-->


        <fact.features.SetLabel
                label="${label}"
        />


        <!--<fact.ShowViewer key="DataCalibrated"/>-->


        <fact.io.JSONWriter keys="MCorsikaEvtHeader.fTotalEnergy,${stat_allPix_param},${stat_phCharge_param},${stat_arrTime_param},${stat_maxSlopes_param},${stat_arrTimePos_param},${stat_maxSlopesPos_param},${stat_maxPos_param},${spread_param},${shower_param},${conc_param},Theta,Alpha,Distance,CosDeltaAlpha,numCluster,boundRatio,idealBoundDiff,boundAngle,distanceCenter,distanceCog,distanceSource,neighborCluster,chargeMax,maxClusterNumPixel,numClusterPixel,stdNumPixel,convexity,stdArrivaltime,boundRatioAT,idealBoundDiffAT,distanceCogMeanAT,numClusterAT,numShowerPixelMotion,clusterNoCleaning" url="${outfolder}${filename}.json"/>

    </process>


</container>
